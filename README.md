Программа с помощью меню реализует следующие команды:

	Базовые:
 - open <fname> <version> - открываем файл в версии <version>. Если версия не задана - открываем корневую версию (ее номер по умолчанию равен 0)
 - print - отображает на экран текущую версию файла, с которым работаем.

	Ф-ии редактирования
 - edit <i> <j> <data> - замена в текущей версии файла данных с индексом i (включительно) по индекс j (не включительно) на символы data
 - add <i> <data> - добавление к текущей версии файла данных, начиная с позиции с индексом i 
 - remove <i> <j> - удаляем данные, как в лабе 3

	Ф-ии работы с версиями
 - push - сохраняем текущую версию в виде разностного образа с предыдущей версией (не с корневой!). Функция возвращает номер версии, по которому можно впоследствии откатиться к этой версии.
 - pull <№ версии> - делает текущей версию с переданным номером (т.е. перемещается по дереву версий, получая текущую версию из разностной информации на пути). Дальнейшее редактирование запоминается как изменения(разность) относительно этой (текущей) версией.
 - delete_version <<№ версии> - удаляет версию из дерева. При этом корректируются наследники этой версии в дереве - разность теперь высчитывается относительно нового корня(предка удаленной вершины)
 - rebase - перебалансирует дерево, помещая текущую версию в корень дерева путем перерассчета разностей версий относительно нового корня. Все номера версий остаются прежними, кроме 2х версий - текущей и бывшей корневой. Их номера меняются местами (т.е. текущая версия становится корнем дерева
с номером 0, прежний корень забирает себе бывший номер этой версии)

Пример:

open a.txt - открываем текст. файл, если такой есть на диске. Если уже есть сохнаненные версии - открываем версию с номером 0.
Пусть в файле a.txt находится текст: ABCDEFGH1234567890

edit 2 3 O - запоминаем (пока без сброса на диск), что 3й символ теперь O. Файл a.txt на диске без изменений.
remove 1 10 - текущая версия теперь выглядит как A34567890.
add 19 aksjhda - ошибка, такого индекса нет.
add 10 uhsdjs - такого тоже нет, ошибка.
add 9 XYZ - текущая версия A34567890XYZ.
push - сохраняет разность на диске в файле a.1 и ввыводит на экран 1 (номер сохраненной версии). В этом файле лежит как можно меньше информации, но которой можно однозначно описать произошедшие изменения относительно предыдущей версии. Нужно понимать, какая версия была предыдущей. Например, там м. лежать:
0
- 1 10
+ 9 XYZ

edit 0 2 IBKS - текущая версия в памяти:  IBKS4567890XYZ
print - выводим IBKSA34567890XYZ На экран
pull 2 - ошибка, нет такой версии
push - вернула 2, создана версия 2, в файле a.2 лежит что-то типа:
1
- 0 2
+ 0 IBKS

pull 1 - восстанавливаем версию 1 - в памяти A34567890XYZ
add 12 ZERO - в памяти A34567890XYZZERO
push - вернула 3, в файле a.3:
1
+ 12 ZERO

print - печатаем A34567890XYZZERO
rebase - переформатирование структуры дерева. Было:
   0
    \
     1
    / \
   2   3

Стало:
       0*
      /
     1*
    / \
   3*  2

Изменились все файлы с версиями на бывшем пути из корня к текущей вершине, остальные не будут меняться, т.к. описывают разность относительно предыдущей.
Теперь:

в a.txt:
A34567890XYZZERO

в a.1:
0
- 12 16

в а.2:
1
- 0 2
+ 0 IBKS

в а.3:
1
- 9 12
+ 1 BCDEFGH12

delete_version 1 -удаляем из дерева версию 1. Предки удаляемой версии не затронуты. Дерево стало:

     0
    / \
   3*  2*

в а.2:
0
- 12 16
- 0 2
+ 0 IBKS

в а.3:
0
- 9 16
+ 1 BCDEFGH12

pull 1 - ошибка, версии на существует.

